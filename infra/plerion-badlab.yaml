AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Plerion Misconfig Lab (Auto CI) - Insecure demo:
  - Public RDS with both GOOD and BAD SGs
  - API Gateway (one public, one custom authorizer)
  - Public S3 bucket
  - SQS queue open to the world
  - Lambda (older runtime), public Function URL, admin perms, secrets in code/env
  - IAM anti-patterns
  - Publicly readable Secrets Manager secret
  - Vulnerable packages via Lambda Layer (built from lock file)

Parameters:
  PublicBucketName:
    Type: String
    Description: Globally-unique S3 bucket name.
  DBMasterUsername:
    Type: String
    Default: badlabuser
    AllowedPattern: '^(?!admin$)(?!postgres$)[a-zA-Z][a-zA-Z0-9_]{0,62}$'
  DBMasterPassword:
    Type: String
    NoEcho: true
    Default: Pl3rionBadLab123!
  LambdaRuntime:
    Type: String
    Default: python3.9
    AllowedValues: [python3.9, python3.10, python3.11, python3.12]
  ApiStageName:
    Type: String
    Default: prod
  ArtifactBucket:
    Type: String
    Description: S3 bucket holding the Lambda layer zip.
  VulnLayerKey:
    Type: String
    Default: layers/vuln-py39-layer.zip
    Description: S3 key for the vulnerable Python layer zip.

Resources:

  # ---------------- VPC & Networking ----------------
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags: [{ Key: Name, Value: PlerionBadLabVPC }]

  IGW:
    Type: AWS::EC2::InternetGateway

  IGWAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref IGW

  PublicSubnetA:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.0.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags: [{ Key: Name, Value: PlerionBadLabPublicA }]

  PublicSubnetB:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags: [{ Key: Name, Value: PlerionBadLabPublicB }]

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC

  PublicRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref IGW

  PublicSubnetARouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetA
      RouteTableId: !Ref PublicRouteTable

  PublicSubnetBRouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetB
      RouteTableId: !Ref PublicRouteTable

  # ---------------- Security Groups & RDS ----------------
  OverPermissiveSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Intentionally over-permissive: ALL traffic from 0.0.0.0/0"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags: [{ Key: Name, Value: PlerionBadLabAllowAll }]

  AppTierSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "App tier SG"
      VpcId: !Ref VPC
      SecurityGroupIngress: []
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  DBGoodSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "GOOD: Only Postgres from AppTierSG"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref AppTierSG
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  DBBadSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "BAD: Postgres open to the world"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: PlerionBadLab Public DB subnets
      SubnetIds: [!Ref PublicSubnetA, !Ref PublicSubnetB]

  BadLabRDS:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Delete
    Properties:
      DBInstanceIdentifier: plerion-badlab-db
      DBName: badlab
      Engine: postgres
      EngineVersion: '15'
      PubliclyAccessible: true
      MasterUsername: !Ref DBMasterUsername
      MasterUserPassword: !Ref DBMasterPassword
      AllocatedStorage: 20
      DBInstanceClass: db.t3.micro
      VPCSecurityGroups: [!Ref DBGoodSG, !Ref DBBadSG]
      DBSubnetGroupName: !Ref DBSubnetGroup
      BackupRetentionPeriod: 0
      AutoMinorVersionUpgrade: false
      StorageEncrypted: false
      MultiAZ: false
      DeletionProtection: false

  # ---------------- S3 (public) ----------------
  PublicBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref PublicBucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      WebsiteConfiguration:
        IndexDocument: index.html
      Tags: [{ Key: Purpose, Value: BadLabPublic }]

  PublicBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref PublicBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowGetFromAnyone
            Effect: Allow
            Principal: "*"
            Action: "s3:GetObject"
            Resource: !Sub "${PublicBucket.Arn}/*"

  # ---------------- SQS (open) ----------------
  OpenQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: plerion-badlab-open-queue

  OpenQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues: [!Ref OpenQueue]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowAllOnQueue
            Effect: Allow
            Principal: "*"
            Action: "sqs:*"
            Resource: !GetAtt OpenQueue.Arn

  # ---------------- Lambda + Layer ----------------
  LambdaAdminRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: PlerionBadLabLambdaAdminRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess
      Policies:
        - PolicyName: Logs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: [logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents]
                Resource: "*"

  VulnPy39Layer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: plerion-badlab-vuln-py39
      Content:
        S3Bucket: !Ref ArtifactBucket
        S3Key: !Ref VulnLayerKey
      CompatibleRuntimes: [python3.9]
      Description: "Intentionally vulnerable Python packages (FOR LAB ONLY)"

  BadLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: plerion-badlab-hello
      Runtime: !Ref LambdaRuntime
      Handler: index.handler
      Role: !GetAtt LambdaAdminRole.Arn
      Timeout: 10
      Layers: [!Ref VulnPy39Layer]
      Environment:
        Variables:
          STRIPE_SECRET_KEY: "sk_live_9r2yYFJk0xQv6D1a7cW8eM5n3pB4tH2L"
          LEAKED_AWS_ACCESS_KEY_ID: "AKIA1234567890ABCD"
          LEAKED_AWS_SECRET_ACCESS_KEY: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
      Code:
        ZipFile: |
          import os, json
          import yaml, jinja2, requests, urllib3

          # "secrets" also present in code (for code/content scanners)
          STRIPE_SECRET_KEY = "sk_live_9r2yYFJk0xQv6D1a7cW8eM5n3pB4tH2L"
          LEAKED_AWS_ACCESS_KEY_ID = "AKIA1234567890ABCD"
          LEAKED_AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"

          def handler(event, context):
              print("Vuln lib versions", {
                  "PyYAML": getattr(yaml, "__version__", None),
                  "Jinja2": getattr(jinja2, "__version__", None),
                  "requests": getattr(requests, "__version__", None),
                  "urllib3": getattr(urllib3, "__version__", None),
              })
              # leak env
              leaked = {k: v for k, v in os.environ.items() if k.startswith(("LEAKED_", "STRIPE_"))}
              print("EnvLeakExample", leaked)

              # echo in body
              return {
                  "statusCode": 200,
                  "body": json.dumps({
                      "ok": True,
                      "env_leaks": leaked,
                      "code_secret_fingerprint": STRIPE_SECRET_KEY[-6:]
                  })
              }

  BadLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${BadLambda}"
      RetentionInDays: 1

  BadLambdaUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !Ref BadLambda
      AuthType: NONE
      Cors:
        AllowOrigins: ["*"]
        AllowMethods: ["GET","POST"]
        AllowHeaders: ["*"]

  BadLambdaUrlPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref BadLambda
      Action: lambda:InvokeFunctionUrl
      Principal: "*"
      FunctionUrlAuthType: NONE

  # ---------------- API Gateway ----------------
  ApiGatewayRest:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: PlerionBadLabAPI
      EndpointConfiguration: { Types: ["REGIONAL"] }

  ApiResourcePublic:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRest
      ParentId: !GetAtt ApiGatewayRest.RootResourceId
      PathPart: public

  ApiResourceSecure:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRest
      ParentId: !GetAtt ApiGatewayRest.RootResourceId
      PathPart: secure

  AuthorizerFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: Logs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: [logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents]
                Resource: "*"

  AuthorizerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: plerion-badlab-authorizer
      Runtime: !Ref LambdaRuntime
      Handler: index.handler
      Role: !GetAtt AuthorizerFunctionRole.Arn
      Code:
        ZipFile: |
          def handler(event, context):
              token = (event.get('authorizationToken') or '').lower()
              effect = 'Allow' if 'allow' in token else 'Deny'
              return {
                  "principalId": "user",
                  "policyDocument": {
                      "Version": "2012-10-17",
                      "Statement": [{
                          "Action": "execute-api:Invoke",
                          "Effect": effect,
                          "Resource": event["methodArn"]
                      }]
                  }
              }

  AuthorizerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AuthorizerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRest}/authorizers/*

  TokenAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    DependsOn: AuthorizerPermission
    Properties:
      Name: !Sub "BadLabTokenAuthorizer-${AWS::StackName}"
      RestApiId: !Ref ApiGatewayRest
      Type: TOKEN
      AuthorizerUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AuthorizerFunction.Arn}/invocations
      IdentitySource: method.request.header.Authorization
      AuthorizerResultTtlInSeconds: 0

  PublicGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRest
      ResourceId: !Ref ApiResourcePublic
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${BadLambda.Arn}/invocations
      MethodResponses: [{ StatusCode: 200 }]

  SecureGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRest
      ResourceId: !Ref ApiResourceSecure
      HttpMethod: GET
      AuthorizationType: CUSTOM
      AuthorizerId: !Ref TokenAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${BadLambda.Arn}/invocations
      MethodResponses: [{ StatusCode: 200 }]

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: [PublicGetMethod, SecureGetMethod]
    Properties:
      RestApiId: !Ref ApiGatewayRest
      StageName: !Ref ApiStageName

  LambdaInvokeFromApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref BadLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRest}/*/*/*"

  # ---------------- IAM Anti-Patterns ----------------
  EscalationAdminRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: PlerionBadLabEscalationAdminRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess


  BreakGlassUser:
    Type: AWS::IAM::User
    Properties:
      UserName: break-glass-admin
      ManagedPolicyArns: [arn:aws:iam::aws:policy/AdministratorAccess]
      Tags: [{ Key: Purpose, Value: BadLab }]

  BreakGlassAccessKey:
    Type: AWS::IAM::AccessKey
    Properties:
      UserName: !Ref BreakGlassUser

  DevsGroup:
    Type: AWS::IAM::Group
    Properties:
      GroupName: plerion-badlab-devs
      Policies:
        - PolicyName: EverythingEverywhereAllAtOnce
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: "*"
                Resource: "*"

  DevUser:
    Type: AWS::IAM::User
    Properties:
      UserName: dev-user
      Groups: [!Ref DevsGroup]

  DevUserKey:
    Type: AWS::IAM::AccessKey
    Properties:
      UserName: !Ref DevUser

  # ---------------- Public Secret ----------------
  BadSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: plerion/badlab/public-secret
      Description: "Intentionally misconfigured: public-readable secret"
      SecretString: '{"SuperSecretProdKey":"shh-12345"}'

  BadSecretPolicy:
    Type: AWS::SecretsManager::ResourcePolicy
    Properties:
      SecretId: !Ref BadSecret
      ResourcePolicy:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowAnyoneReadSecret
            Effect: Allow
            Principal: "*"
            Action: "secretsmanager:GetSecretValue"
            Resource: !Ref BadSecret

Outputs:
  PublicBucketNameOut:
    Value: !Ref PublicBucketName
  RDSAddress:
    Value: !GetAtt BadLabRDS.Endpoint.Address
  BadLambdaRuntime:
    Value: !Ref LambdaRuntime
  BadLambdaFunctionUrl:
    Value: !GetAtt BadLambdaUrl.FunctionUrl
  ApiInvokePublic:
    Value: !Sub "https://${ApiGatewayRest}.execute-api.${AWS::Region}.amazonaws.com/${ApiStageName}/public"
  ApiInvokeSecure:
    Value: !Sub "https://${ApiGatewayRest}.execute-api.${AWS::Region}.amazonaws.com/${ApiStageName}/secure"
  BreakGlassAccessKeyId:
    Value: !Ref BreakGlassAccessKey
  BreakGlassSecretAccessKey:
    Value: !GetAtt BreakGlassAccessKey.SecretAccessKey
  DevUserAccessKeyId:
    Value: !Ref DevUserKey
  DevUserSecretAccessKey:
    Value: !GetAtt DevUserKey.SecretAccessKey
  EscalationAdminRoleArn:
    Value: !GetAtt EscalationAdminRole.Arn
